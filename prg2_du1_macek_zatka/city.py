from PySide2.QtCore import QObject, Slot, Property, QUrl, Signal, QTimer, QAbstractListModel, QByteArray
from PySide2.QtGui import QGuiApplication
from PySide2.QtQuick import QQuickView
from PySide2.QtPositioning import QGeoCoordinate
from PySide2 import QtCore
import sys
import json
import typing
from enum import Enum

VIEW_URL = "view.qml"
SEZNAM_OBCI = "obce.geojson"

class ObceModel(QAbstractListModel):
    
    class Roles(Enum):
        LOC = QtCore.Qt.UserRole+0
        POP = QtCore.Qt.UserRole+1
        AREA = QtCore.Qt.UserRole+2
        DISTRICT = QtCore.Qt.UserRole+3
        REGION = QtCore.Qt.UserRole+4
        IS_CITY = QtCore.Qt.UserRole+5
        
    def __init__(self, filename=None):
        QAbstractListModel.__init__(self)
        self.seznam_obci = []
        if filename:
            self.load_from_json(filename)

    def load_from_json(self, filename):
        with open (filename, encoding = "utf-8") as file:
            self.seznam_obci = json.load(file)

            for entry in self.seznam_obci["features"]:
                lon = entry["geometry"]["coordinates"][0]
                lat = entry["geometry"]["coordinates"][1]
                entry["geometry"]["coordinates"] = QGeoCoordinate(float(lat), float(lon))
    
    def rowCount(self, parent:QtCore.QModelIndex=...) -> int:
        return len(self.seznam_obci["features"])
        

    def data(self, index:QtCore.QModelIndex, role:int=...) -> typing.Any:
        if role == QtCore.Qt.DisplayRole:
            return self.seznam_obci["features"][index.row()]["properties"]["NAZ_OBEC"]
        elif role == self.Roles.LOC.value: 
            return self.seznam_obci["features"][index.row()]["geometry"]["coordinates"]
        elif role == self.Roles.POP.value:
            return self.seznam_obci["features"][index.row()]["properties"]["POCET_OBYV"]
        elif role == self.Roles.AREA.value:
            return round(self.seznam_obci["features"][index.row()]["properties"]["area"],2)
        elif role == self.Roles.DISTRICT.value:
            return self.seznam_obci["features"][index.row()]["properties"]["NAZ_OKRES"]
        elif role == self.Roles.REGION.value:
            return self.seznam_obci["features"][index.row()]["properties"]["NAZ_KRAJ"]
        elif role == self.Roles.IS_CITY.value:
            if self.seznam_obci["features"][index.row()]["properties"]["is_city"] == "TRUE":
                return "MÄ›sto"
            else:
                return "Vesnice" 
            #return self.seznam_obci["features"][index.row()]["properties"]["is_city"]


    def roleNames(self) -> typing.Dict[int, QByteArray]:
        roles = super().roleNames()
        roles[self.Roles.LOC.value] = QByteArray(b'location')
        roles[self.Roles.POP.value] = QByteArray(b'population')
        roles[self.Roles.AREA.value] = QByteArray(b'area')
        roles[self.Roles.DISTRICT.value] = QByteArray(b'district')
        roles[self.Roles.REGION.value] = QByteArray(b'region')
        roles[self.Roles.IS_CITY.value] = QByteArray(b'township')
        print(roles)
        return roles

###

class CountdownModel(QObject):
    """CountdownModel is the model class for the GUI. It holds the counter property
     and handles event generated by the click on the button."""

    def __init__(self):
        QObject.__init__(self)
        # Value to count from
        self.total = 30
        self._remaining = 30
        # Timer
        self.timer = QTimer()
        self.timer.setInterval(1000)
        self.timer.timeout.connect(self.process_timer)

    def set_remaining(self, val):
        if val != self._remaining:
            self._remaining = val
            self.remaining_changed.emit()
            # If the timer is inactive, update also a value to count from
            if not self.timer.isActive():
                self.total = self.remaining

    remaining_changed = Signal()
    # Property holding actual remaining number of seconds
    remaining = Property(int, lambda self: self._remaining, set_remaining, notify=remaining_changed)

    timeout = Signal()

    @Slot()
    def process_timer(self):
        """Handler for the timer event.
        Decrease the remaining value or stop the timer and emit timeout signal if the time is over"""
        if self.remaining == 1:
            self.timer.stop()
            self.remaining = self.total     # Reset the timer value
            self.timeout.emit()
            return
        self.remaining -= 1

    @Slot()
    def start(self):
        """Start the countdown"""
        print("Starting")
        print(self.total,self.remaining)
        self.timer.start()

    @Slot()
    def pause(self):
        """Pause the countdown"""
        print("Pausing")
        print(self.total,self.remaining)
        self.timer.stop()

    @Slot()
    def stop(self):
        """Stop (and reset) the countdown"""
        print("Stopping")
        print(self.total,self.remaining)
        self.timer.stop()
        self.remaining = self.total


app = QGuiApplication(sys.argv)
view = QQuickView()
url = QUrl(VIEW_URL)
obce_model = ObceModel(SEZNAM_OBCI)
ctxt = view.rootContext()
ctxt.setContextProperty("ObceModel", obce_model)
view.setSource(url)
view.show()
app.exec_()